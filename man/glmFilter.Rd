% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmFilter.R
\name{glmFilter}
\alias{glmFilter}
\title{Unsupervised Spatial Filtering with Eigenvectors in Generalized
Linear Regression Models}
\usage{
glmFilter(
  y,
  x = NULL,
  W,
  objfn = "MI",
  MX = F,
  model,
  optim.method = "BFGS",
  sig = 0.05,
  bonferroni = TRUE,
  positive = TRUE,
  min.reduction = 0.05,
  boot.MI = 100,
  resid.type = "pearson",
  alpha = 0.25,
  tol = 0.1,
  na.rm = T
)
}
\arguments{
\item{y}{vector of regressands}

\item{x}{vector/ matrix of regressors (default=NULL)}

\item{W}{spatial connectivity matrix}

\item{objfn}{specifies the objective function to be used for eigenvector
selection. Possible criteria are: the maximization of the
adjusted R-squared ('AIC' or 'BIC'), minimization of residual autocorrelation ('MI'),
significance level of candidate eigenvectors ('p'), or
all eigenvectors in the candidate set ('all')}

\item{MX}{covariates used to construct the projection matrix (TRUE/ FALSE)}

\item{model}{a character string indicating the model to be estimated.
Currently, 'probit', 'logit', and 'poisson' are valid inputs}

\item{optim.method}{a character specifying the optimization method}

\item{sig}{significance level to be used for eigenvector selection
if \code{objfn='p'}}

\item{bonferroni}{Bonferroni adjustment for the significance level
(TRUE/ FALSE)}

\item{positive}{restrict search to eigenvectors associated with positive
levels of spatial autocorrelation (TRUE/ FALSE)}

\item{min.reduction}{if \code{objfn} is either 'AIC' or 'BIC'. A value in the
interval [0,1) that determines the minimum reduction in AIC/ BIC a candidate
eigenvector need to achieve in order to be selected}

\item{boot.MI}{number of iterations used to estimate the variance of Moran's I
(default=100). Alternatively, if \code{boot=NULL}, analytical results will
be used}

\item{resid.type}{character string specifying the residual type to be used.
Options are 'raw', 'deviance', and 'pearson' (default)}

\item{alpha}{a value in (0,1] indicating the range of candidate eigenvectors
according to their associated level of spatial autocorrelation, see e.g.,
Griffith (2003)}

\item{tol}{if \code{objfn='MI'}, determines the amount of remaining residual
autocorrelation at which the eigenvector selection terminates}

\item{na.rm}{remove missing values in variables (TRUE/ FALSE)}
}
\value{
An object of class \code{spfilter} containing the following
information:
\describe{
\item{\code{Estimates}}{summary statistics of the parameter estimates}
\item{\code{varcovar}}{estimated variance-covariance matrix}
\item{\code{EV}}{a matrix with summary statistics of selected eigenvectors}
\item{\code{selvecs}}{matrix of selected eigenvectors}
\item{\code{evMI}}{Moran coefficient of all eigenvectors}
\item{\code{moran}}{residual autocorrelation for the initial and the
filtered model}
\item{\code{fit}}{adjusted R-squared of the initial and the filtered model}
\item{\code{residuals}}{initial and filtered model residuals}
\item{\code{other}}{a list providing supplementary information:
\describe{
\item{\code{ncandidates}}{number of candidate eigenvectors considered}
\item{\code{nev}}{number of selected eigenvectors}
\item{\code{condnum}}{condition number to assess the degree of multicollinearity
among the eigenvectors induced by the link function, see e.g., Griffith/ Amrhein
(1997)}
\item{\code{sel_id}}{ID of selected eigenvectors}
\item{\code{sf}}{vector representing the spatial filter}
\item{\code{sfMI}}{Moran coefficient of the spatial filter}
\item{\code{model}}{class of the regression model}
\item{\code{MX}}{TRUE/ FALSE: include covariates in the projection matrix
\emph{\strong{M}}}
\item{\code{dependence}}{filtered for positive or negative spatial dependence}
\item{\code{objfn}}{selection criteria specified in the objective function of
the steppwise regression procedure}
\item{\code{bonferroni}}{TRUE/ FALSE: Bonferroni-adjusted significance level
(if \code{objfn='p'})}
\item{\code{siglevel}}{if \code{objfn='p'}: actual (unadjusted/ adjusted)
significance level}
\item{\code{resid.type}}{residual type used ('raw', 'deviance', or 'pearson')}
\item{\code{pseudoR2}}{McFadden's pseudo R-squared (filtered vs. unfiltered model)}
}
}
}
}
\description{
This function implements the eigenvector-based semiparametric
spatial filtering approach in a generalized linear regression framework using MLE.
Eigenvectors are selected by an unsupervised steppwise regression
technique. Supported selection criteria are the minimization of residual
autocorrelation, maximization of model fit, and the statistical significance
of eigenvectors. Alternatively, all eigenvectors in the candidate set
can be included as well.
}
\details{
If \emph{\strong{W}} is not symmetric, it gets symmetrized by
1/2 * (\emph{\strong{W}} + \emph{\strong{W}}') the eigenfunction decomposition.

If \code{MX=TRUE}, the function uses the covariates specified in the argument
\code{x} to construct the following projection matrix:

\emph{\strong{M} = \strong{I} - \strong{X} (\strong{X}'\strong{X})^-1\strong{X}'}

Eigenvectors from \emph{\strong{MWM}} using this specification of
\emph{\strong{M}} are not only mutually uncorrelated but also orthogonal
to the included regressors. Alternatively, if \code{MX=FALSE}, the projection
matrix becomes \emph{\strong{M} = \strong{I} - \strong{11}'/\emph{n}}, where
\emph{\strong{1}} is a vector of ones and \emph{n} represents the number of
observations. Griffith and Tiefelsdorf (2007) show how the choice of the appropriate
\emph{\strong{M}} depends on the underlying process that generates the spatial
dependence.
}
\note{
If the condition number (\code{condnum}) suggests high levels of multicollinearity,
problematic eigenvectors can be manually removed from \code{selvecs} and
the model can be reestimated using the \code{glm} function. Moreover, if other models that
are currently not implemented here need to be estimated (e.g., quasi-binomials),
users can extract eigenvectors using the function \code{getEVs} and perform a
supervised eigenvector search using the \code{glm} function.
}
\examples{
data(fakedata)

# poisson model
y_pois <- fakedataset$count
poisson <- glmFilter(y=y_pois,x=NULL,W=W,objfn="MI",positive=FALSE
,model="poisson",boot.MI=100)
print(poisson)
summary(poisson,EV=FALSE)

# probit model - summarize EVs
y_prob <- fakedataset$indicator
probit <- glmFilter(y=y_prob,x=NULL,W=W,objfn="MI",positive=FALSE
,model="probit",boot.MI=100)
print(probit)
summary(probit,EV=TRUE)

# logit model - AIC objective function
y_logit <- fakedataset$indicator
logit <- glmFilter(y=y_logit,x=NULL,W=W,objfn="AIC",positive=FALSE
,model="logit",min.reduction=.05)
print(logit)
summary(logit,EV=FALSE)

}
\references{
Tiefelsdorf, Michael and Daniel A. Griffith (2007):
Semiparametric filtering of spatial autocorrelation: the eigenvector
approach. Environment and Planning A: Economy and Space, 39 (5):
pp. 1193 - 1221.

Griffith, Daniel A. (2003): Spatial Autocorrelation and Spatial Filtering:
Gaining Understanding Through Theory and Scientific Visualization.
Berlin/ Heidelberg, Springer.

Griffith, Daniel A. and Carl G. Amrhein (1997): Multivariate Statistical
Analysis for Geographers. Englewood Cliffs, Prentice Hall.
}
\seealso{
\code{\link{lmFilter}}, \code{\link{getEVs}}, \code{\link{getMoran}}
}
